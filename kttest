#!/bin/sh
scpName=`basename $0 .sh`
scpVer=1.0

help()
{
cat >/dev/stderr <<EOF
-----------------------------------------------------------------------------
$scpName version $scpVer
-----------------------------------------------------------------------------
概要) 2値の対応のないT検定を行う。
書式) $scpName -k 項目名  
			      [-i 入力ファイル名][-o 出力ファイル名][-T ワークディレクトリ名][-h]

解説)
-k 2値（0,1）が入った項目（必ず一番左側）
-i 入力ファイル
-o 出力ファイル
-h ヘルプの表示
例) $scpName -k class -i input -o output

$ more input.csv
label,fld1,fld2
0,26.1,174947
0,28.8,93731
0,32.0,105240
0,53.2,82473
0,36.8,104057
0,30.4,85047
0,21.9,47023
1,42.6,104578
0,42.6,168247
0,57.5,94216
0,39.4,124064
0,45.3,314144
    ・
    ・
    ・
$ $scpName -k label -i input.csv -o output.csv
$ more outout.csv
$ more xxttest_o.csv
fld,label0_mean,label1_mean,f.test,t,p_value,t_check
fld1,48.8533333333333,53.1679245283019,TRUE,-3.239576,0.001307,**
fld2,110876.787709497,113014.236363636,TRUE,-0.242267,0.808694,n.s    

p_value < 0.05 で有意と判断できる。＊の数が多いほど良い

2017/02/10 北島 聡 : 1.0 新規作成
Powered by R
-----------------------------------------------------------------------------
EOF
exit 1
}


#完了メッセージ用にコマンドラインを保存
cmdLine="$scpName""(""$scpVer"") ""$*"

#シグナルによる終了
function endByInt {
    rm -f $TD-xx*
    echo "#ERROR#" \"$cmdLine\" \""end by signal(ctr^C)"\" >/dev/stderr
    exit 1
} 



#パラメータのチェック＆セット
while getopts "k:i:o:T:V:h" opt; do
    case $opt in
    k  ) key=$OPTARG ;;
	i  ) input=$OPTARG ;;
	o  ) output=$OPTARG ;;
	T  ) tmpD=$OPTARG ;;
	V  ) KG_VerboseLevel=$OPTARG ;;
	h  ) help ;;
	\? ) help ;;
    esac
done
shift $(($OPTIND -1 ))

if [ "$key" = "" ]; then
    echo "#ERROR# \"$0\" \"オプション -k は必須条件です。\"" >/dev/stderr
    exit 1
fi
if [ "$input" = "" ]; then
    input=/dev/stdin
fi
if [ "$output" = "" ]; then
    output=/dev/stdout
fi
if [ "$tmpD" = "" ]; then
    tmpD=/tmp
fi
if [ "$KG_VerboseLevel" == "" ]; then
#デフォルトでは、コマンドのメッセージはOFF
#0:何も表示しない
#1:エラーのみ表示
#2:+処理メッセージ表示
#3:+終了メッセージ表示
  export KG_VerboseLevel=1
else
  export KG_VerboseLevel=$KG_VerboseLevel
fi
#ワークファイルのプレフィックスの設定
#TD=$tmpD/xx$$-$scpName
aec=xx$$-$scpName
TD=$tmpD/$aec

#トラップ発動
trap endByInt INT QUIT TERM HUP

# http://fuyukoma.sakura.ne.jp/works/rでまとめてt検定-csvで読み込みから書き出しまで/

echo "
data <- read.csv(\"${input}\", header=T)
  
#比較する群を分ける。
data0 <- subset(data, ${key}==0)
data1 <- subset(data, ${key}==1)
 
tResult <- function(x,y,fld){
    ft <- var.test(x, y,na.rm=TRUE) # F検定
    fp <- sprintf(\"%f\", ft\$p.value)
    if(!is.na(ft\$p.value)){
        if(ft\$p.value >= 0.05){ # 等分散の場合（var.equal=Tとする）
          t_varEqual<-T
          t_test<-\"TRUE\"
        } else {                  # 不等分散
          t_varEqual<-F
          t_test<-\"FALSE\"
        }
        tt <- t.test(x, y, na.rm=TRUE, var.equal=t_varEqual)
        tp <- sprintf(\"%f\", tt\$p.value)
        tv <- sprintf(\"%f\", tt\$statistic)
        if(tt\$p.value < 0.005) { # p<.005の場合
            tc <- \"***\"
        } else if(tt\$p.value < 0.01) { # p<.01の場合
            tc <- \"**\"
        } else if(tt\$p.value < 0.05) { # p<.05の場合
            tc <- \"*\"
        } else if(tt\$p.value < 0.10) {
            tc <- \"+\"
        } else {
            tc <- \"n.s\"
        }
        res <- data.frame(fld, label0_mean=mean(x,na.rm=TRUE), label1_mean=mean(y,na.rm=TRUE), f.test=_test, t=tv, p_value=tp, t_check=tc)
        write(paste(\"#END#\",fld), stderr())
        return(res)
    } else {
        write(paste(\"#ERROR#\",fld), stderr())
    }
} 

t_res <- data.frame();
for(i in 2:ncol(data)) { # 検定したい項目の列番号。
    t_res <- rbind(t_res, tResult(data0[,i], data1[,i], colnames(data)[i] ) )
}
write.csv(t_res, \"${output}\", quote=F, row.names = FALSE )

" > $TD-xxa.R


if [ $KG_VerboseLevel -gt 1 ]; then
    /Library/Frameworks/R.framework/Resources/R CMD BATCH --quiet $TD-xxa.R
    cat $aec-xxa.Rout
    rm $aec* 
else
    /Library/Frameworks/R.framework/Resources/R CMD BATCH --no-restore-history $TD-xxa.R
    rm $aec* 
fi
rm -f $TD-xx*

#完了メッセージ表示
echo "#END# "\"$cmdLine \" >/dev/stderr
exit 0
