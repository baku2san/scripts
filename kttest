#!/bin/sh
scpName=`basename $0 .sh`
scpVer=1.0

help()
{
cat >/dev/stderr <<EOF
-----------------------------------------------------------------------------
$scpName version $scpVer
-----------------------------------------------------------------------------
概要) 2値の対応のないT検定を行う。
書式) $scpName -k 項目名  
			      [-i 入力ファイル名][-o 出力ファイル名][-T ワークディレクトリ名][-m][-h]

解説)
-k 2値（0,1）が入った項目（必ず一番左側）
-i 入力ファイル
-o 出力ファイル
-m 修正実行
  # 1. keyが先頭列にない。
  # 2. keyが文字列→最高頻度の文字列を 1 その他を 0 として実施
-h ヘルプの表示
例) $scpName -k class -i input -o output

$ more input.csv
label,fld1,fld2
0,26.1,174947
0,28.8,93731
0,32.0,105240
0,53.2,82473
0,36.8,104057
0,30.4,85047
0,21.9,47023
1,42.6,104578
0,42.6,168247
0,57.5,94216
0,39.4,124064
0,45.3,314144
    ・
    ・
    ・
$ $scpName -k label -i input.csv -o output.csv
$ more outout.csv
$ more xxttest_o.csv
fld,label0_mean,label1_mean,f.test,t,p_value,t_check
fld1,48.8533333333333,53.1679245283019,TRUE,-3.239576,0.001307,**
fld2,110876.787709497,113014.236363636,TRUE,-0.242267,0.808694,n.s    

p_value < 0.05 で有意と判断できる。＊の数が多いほど良い

2017/02/10 北島 聡 : 1.0 新規作成
Powered by R
-----------------------------------------------------------------------------
EOF
exit 1
}


#完了メッセージ用にコマンドラインを保存
cmdLine="$scpName""(""$scpVer"") ""$*"

#シグナルによる終了
function endByInt {
    rm -f $TD-xx*
    echo "#ERROR#" \"$cmdLine\" \""end by signal(ctr^C)"\" >/dev/stderr
    exit 1
} 



#パラメータのチェック＆セット
while getopts "k:i:mo:T:V:h" opt; do
    case $opt in
    k  ) key=$OPTARG ;;
    m  ) modify=true ;;
    i  ) input=$OPTARG ;;
    o  ) output=$OPTARG ;;
    T  ) tmpD=$OPTARG ;;
    V  ) KG_VerboseLevel=$OPTARG ;;
    h  ) help ;;
    \? ) help ;;
    esac
done
shift $(($OPTIND -1 ))

if [ "$key" = "" ]; then
    echo "#ERROR# \"$0\" \"オプション -k は必須条件です。\"" >/dev/stderr
    exit 1
fi
if [ "$input" = "" ]; then
    input=/dev/stdin
fi
if [ "$output" = "" ]; then
    output=/dev/stdout
fi
if [ "$tmpD" = "" ]; then
    tmpD=/tmp
fi
if [ "$KG_VerboseLevel" == "" ]; then
#デフォルトでは、コマンドのメッセージはOFF
#0:何も表示しない
#1:エラーのみ表示
#2:+処理メッセージ表示
#3:+終了メッセージ表示
  export KG_VerboseLevel=1
else
  export KG_VerboseLevel=$KG_VerboseLevel
fi
#ワークファイルのプレフィックスの設定
#TD=$tmpD/xx$$-$scpName
aec=xx$$-$scpName
TD=$tmpD/$aec

#トラップ発動
trap endByInt INT QUIT TERM HUP

if [ ${modify} ];then
  # 以下の事前チェックを行い自動修正する。
  # 1. keyが先頭列にない。
  # 2. 文字列Column　→最高頻度の文字列を 1 その他を 0 として実施
  # 3. keyと全く同一の動きを見せるBoolean列：＜ERROR対処しない。
  inputOriginal=$input
  input=`mktemp`
  targetLines=100   # Numericalの判断をRandomの何行で行うか？全部だと重いだろうから。
  validColumns=$key
  invalidColumns=
  for column in `head -n1 $inputOriginal | sed -e "s/\%[^,]*//g" | tr "," "\n"`
  do
    if [ "$column" == "$key" ];then
      keyTemp=`mktemp`
      columnCount=countTmp
      mcount k=$key a=$columnCount i=$inputOriginal o=$keyTemp
      lineCount=`wc -l $keyTemp | grep -oE "^\s*([0-9]+)"`
      if [ $lineCount -gt 2 ];then
        # echo "The key has 3 or more types of characters. Be boolean such as 0 or 1."
        # the previous condition has been included cause of changing muniq to mcount.
        word1=`mbest i=$keyTemp s=${columnCount}%nr from=0 size=1 |
              mcut f=$key | tail -n +2`
        inputAsBool=`mktemp`
        keyAsBool=${key}AsBool
        echo To analyze, [ $word1 ] as value is replaced by 1 and the other is 0 at [ ${key} ] as the key.
        mcal i=$inputOriginal c='$s{'$key'}=="'$word1'"' a=$keyAsBool o=$inputAsBool
        validColumns=${validColumns//$key/$keyAsBool}
        inputOriginal=$inputAsBool
        key=$keyAsBool
        
      elif [ $lineCount -eq 2 ];then
        echo "The key would be constant. Check for the data and be careful if it is boolean."
        exit
  #   else # -eq 1 which means it might has been already boolean.
              # key has been already added to validColumns, thus, there is nothing to do. 
      fi
    else
      lineCount=`mselrand i=$inputOriginal c=$targetLines |
        muniq k=$column |
        msel c='n2s(${'$column'})!=$s{'$column'}' |
        wc -l |
        grep -oE "^\s*([0-9]+)"`
      if [ $lineCount -gt 1 ];then
        invalidColumns=$invalidColumns,$column
      else
        validColumns=$validColumns,$column
      fi
    fi
  done
  # 修正データによる分析
  mcut i=$inputOriginal f=$validColumns o=$input
fi  # end of modify

# http://fuyukoma.sakura.ne.jp/works/rでまとめてt検定-csvで読み込みから書き出しまで/

echo "
data <- read.csv(\"${input}\", header=T)
  
#比較する群を分ける。
data0 <- subset(data, ${key}==0)
data1 <- subset(data, ${key}==1)
 
tResult <- function(x,y,fld){
    ft <- var.test(x, y,na.rm=TRUE) # F検定
    fp <- sprintf(\"%f\", ft\$p.value)
    if(!is.na(ft\$p.value)){
        if(ft\$p.value >= 0.05){ # 等分散の場合（var.equal=Tとする）
          t_varEqual<-T
          t_test<-\"TRUE\"
        } else {                  # 不等分散
          t_varEqual<-F
          t_test<-\"FALSE\"
        }
        tt <- t.test(x, y, na.rm=TRUE, var.equal=t_varEqual)
        tp <- sprintf(\"%f\", tt\$p.value)
        tv <- sprintf(\"%f\", tt\$statistic)
        if(tt\$p.value < 0.005) { # p<.005の場合
            tc <- \"***\"
        } else if(tt\$p.value < 0.01) { # p<.01の場合
            tc <- \"**\"
        } else if(tt\$p.value < 0.05) { # p<.05の場合
            tc <- \"*\"
        } else if(tt\$p.value < 0.10) {
            tc <- \"+\"
        } else {
            tc <- \"n.s\"
        }
        res <- data.frame(fld, label0_mean=mean(x,na.rm=TRUE), label1_mean=mean(y,na.rm=TRUE), f.test=t_test, t=tv, p_value=tp, t_check=tc)
        write(paste(\"#END#\",fld), stderr())
        return(res)
    } else {
        write(paste(\"#ERROR#\",fld), stderr())
    }
} 

t_res <- data.frame();
for(i in 2:ncol(data)) { # 検定したい項目の列番号。
    t_res <- rbind(t_res, tResult(data0[,i], data1[,i], colnames(data)[i] ) )
}
write.csv(t_res, \"${output}\", quote=F, row.names = FALSE )

" > $TD-xxa.R


if [ $KG_VerboseLevel -gt 1 ]; then
    /Library/Frameworks/R.framework/Resources/R CMD BATCH --quiet $TD-xxa.R
    cat $aec-xxa.Rout
    rm $aec* 
else
    /Library/Frameworks/R.framework/Resources/R CMD BATCH --no-restore-history $TD-xxa.R
    rm $aec* 
fi
rm -f $TD-xx*

#完了メッセージ表示
echo "#END# "\"$cmdLine \" >/dev/stderr
exit 0
